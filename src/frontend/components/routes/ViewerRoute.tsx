/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the project root for license terms and full copyright notice.
*--------------------------------------------------------------------------------------------*/

import React from "react"; 
import {
  Viewer,
  ViewerContentToolsProvider,
  ViewerNavigationToolsProvider,
  ViewerStatusbarItemsProvider,
} from "@itwin/desktop-viewer-react";
import { MeasureToolsUiItemsProvider } from "@itwin/measure-tools-react";
import {
  AncestorsNavigationControls,
  CopyPropertyTextContextMenuItem,
  createPropertyGrid,
  ShowHideNullValuesSettingsMenuItem,
} from "@itwin/property-grid-react";
import {
  CategoriesTreeComponent,
  createTreeWidget,
  ModelsTreeComponent,
} from "@itwin/tree-widget-react";
import { useEffect, useState } from "react";
import { useLocation } from "react-router-dom";

import { viewerRpcs, channelName } from "../../../common/ViewerConfig";
import {
  unifiedSelectionStorage,
} from "../../../selectionStorage";
import { IpcApp, IModelApp, Viewport } from "@itwin/core-frontend";
import { Api, SnapshotRow } from "../../services/api";

function PickDialog<T>(props: {
  open: boolean;
  title: string;
  items: T[];
  render: (item: T, index: number) => React.ReactNode;
  onCancel: () => void;
  onPick: (index: number) => void;
}) {
  const { open, title, items, render, onCancel, onPick } = props;
  const [idx, setIdx] = React.useState(0);
  React.useEffect(() => setIdx(0), [open]);
  if (!open) return null;
  return (
    <div style={{
      position: "fixed", inset: 0, background: "rgba(0,0,0,0.5)",
      display: "flex", alignItems: "center", justifyContent: "center", zIndex: 9999,
    }}>
      <div style={{ background: "#1e1e1e", border: "1px solid #333", borderRadius: 8, width: 560, maxHeight: "70vh", padding: 16, display: "flex", flexDirection: "column" }}>
        <div style={{ fontWeight: 700, marginBottom: 10 }}>{title}</div>
        <div style={{ overflow: "auto", flex: 1, border: "1px solid #333", borderRadius: 6 }}>
          {items.map((it, i) => (
            <div
              key={i}
              onClick={() => setIdx(i)}
              style={{
                padding: "8px 10px",
                borderBottom: "1px solid #2a2a2a",
                cursor: "pointer",
                background: i === idx ? "rgba(100,200,255,0.06)" : "transparent",
              }}
            >
              {render(it, i)}
            </div>
          ))}
          {!items.length && <div style={{ padding: 10, opacity: 0.7 }}>Ìï≠Î™©Ïù¥ ÏóÜÏäµÎãàÎã§.</div>}
        </div>
        <div style={{ display: "flex", gap: 8, justifyContent: "flex-end", marginTop: 10 }}>
          <button onClick={onCancel}>Ï∑®ÏÜå</button>
          <button onClick={() => onPick(idx)} disabled={!items.length}>Ïó¥Í∏∞</button>
        </div>
      </div>
    </div>
  );
}

export interface ViewerRouteState { filePath?: string; siteId?: string; siteName?: string; }

export const ViewerRoute = () => {
  const location = useLocation();
  const [filePath, setFilePath] = useState<string>();
  const [siteId, setSiteId] = useState<string | undefined>();
  const [pickOpen, setPickOpen] = useState(false);
  const [snapshots, setSnapshots] = useState<SnapshotRow[]>([]);
  const [snapDir, setSnapDir] = useState<string>("");
  const [pendingServerUrl, setPendingServerUrl] = useState<string | null>(null);

  // ‚úÖ Î°úÏª¨ Ïä§ÎÉÖÏÉ∑ Ìè¥Îçî(.env)
  const SNAP_DIR = (import.meta as any).env?.VITE_SNAPSHOT_DIR?.toString() || "";

  // ÏÑúÎ≤Ñ URL ‚Üí Î°úÏª¨ Í≤ΩÎ°ú
  const urlToLocalPath = React.useCallback((u: string) => {
    const fname = (u || "").split("/").pop() || "";
    if (!snapDir || !fname) {
      console.warn("[Viewer] SNAP_DIR/filename missing", { snapDir, u });
      return "";
    }
    const sep = snapDir.includes("\\") ? "\\" : "/";
    const base = snapDir.replace(/[\\/]+$/, "");
    const full = `${base}${sep}${fname}`;
    console.log("[Viewer] local snapshot path =", full);
    return full;
  }, [snapDir]);

  // Ïä§ÎÉÖÏÉ∑ Ìè¥Îçî ÌôïÎ≥¥: env ‚Üí settings ‚Üí ÏÇ¨Ïö©Ïûê ÏÑ†ÌÉù(1Ìöå Ï†ÄÏû•)
  useEffect(() => {
    (async () => {
      // 1) env
      const envDir = (import.meta as any).env?.VITE_SNAPSHOT_DIR?.toString() || "";
      if (envDir) { setSnapDir(envDir); return; }

      // 2) settings
      const saved = await IpcApp.callIpcChannel(channelName, "getSnapshotDir") as string;
      if (saved) { setSnapDir(saved); return; }

      // 3) ÏÇ¨Ïö©ÏûêÏóêÍ≤å ÏÑ†ÌÉù
      const pick: any = await IpcApp.callIpcChannel(channelName, "openDirectory", {
        title: "Ïä§ÎÉÖÏÉ∑ Î°úÏª¨ Ìè¥Îçî ÏÑ†ÌÉù",
        properties: ["openDirectory"],
      });
      const dir = pick?.filePaths?.[0];
      if (dir) {
        await IpcApp.callIpcChannel(channelName, "setSnapshotDir", dir);
        setSnapDir(dir);
      } else {
        console.warn("[Viewer] snapshot dir not selected");
      }
    })();
  }, []);

  // ÎùºÏö∞Ìä∏ ÏÉÅÌÉú Î∞òÏòÅ + ÏÑúÎ≤Ñ URLÏù¥Î©¥ Î°úÏª¨Î°ú ÏπòÌôò
  useEffect(() => {
    const state = location?.state as ViewerRouteState | undefined;
    setSiteId(state?.siteId);
    if (state?.filePath) {
      // server urlÎ°ú Îì§Ïñ¥Ïò§Îäî Í≤ΩÏö∞ÎèÑ ÏûàÏúºÎãà Î≥ÄÌôò ÏãúÎèÑ
      const maybeLocal = state.filePath.startsWith("/") ? urlToLocalPath(state.filePath) : state.filePath;
      if (maybeLocal) setFilePath(maybeLocal);
    } else {
      setFilePath(undefined);
    }
  }, [location?.state, urlToLocalPath]);

  // ÏÇ¨Ïù¥Ìä∏ ÏµúÍ∑º Ïä§ÎÉÖÏÉ∑ ÏûêÎèô Î°úÎìú
  useEffect(() => {
    (async () => {
      if (!siteId || filePath) return;
      // üîÅ ÏÇ¨Ïù¥Ìä∏Ïùò ÏµúÍ∑º Ïä§ÎÉÖÏÉ∑ 1Í∞úÎßå(ÎòêÎäî 0/1Í∞ú) Î∞òÌôòÌïòÎäî ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÇ¨Ïö©
      const snaps = await Api.listSiteSnapshots(siteId);
      const serverUrl = snaps?.[0]?.url;
      if (!serverUrl) return;

      if (!snapDir) { setPendingServerUrl(serverUrl); return; }
      const local = urlToLocalPath(serverUrl);
      if (local) setFilePath(local);
    })();
  }, [siteId, filePath, snapDir, urlToLocalPath]);

  // snapDir Ï§ÄÎπÑÎêòÎ©¥ Î≥¥Î•ò Ï≤òÎ¶¨
  useEffect(() => {
    if (!snapDir || !pendingServerUrl || filePath) return;
    const local = urlToLocalPath(pendingServerUrl);
    if (local) {
      setFilePath(local);
      setPendingServerUrl(null);
    }
  }, [snapDir, pendingServerUrl, filePath, urlToLocalPath]);

  // Î©îÎâ¥ File‚ÜíOpen
  useEffect(() => {
    const onMenu = async (_evt: any, command: string) => {
      if (command !== "open") return;
      console.log("[File‚ÜíOpen] menu event");
      try {
        const snaps = await Api.listSnapshotsAll();
        console.log("[File‚ÜíOpen] count =", snaps?.length);
        if (!snaps?.length) { alert("ÏÑúÎ≤ÑÏóê Îì±Î°ùÎêú Ïä§ÎÉÖÏÉ∑Ïù¥ ÏóÜÏäµÎãàÎã§."); return; }
        setSnapshots(snaps);
        setPickOpen(true);
      } catch (e) {
        console.error("[File‚ÜíOpen] error", e);
        alert("Ïä§ÎÉÖÏÉ∑ Î™©Î°ùÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
      }
    };
    // @ts-ignore
    IpcApp.addListener(channelName, onMenu);
    return () => { /* @ts-ignore */ IpcApp.removeListener?.(channelName, onMenu); };
  }, [siteId]);

  useEffect(() => {
    if (!filePath) return;

    const onOpen = (vp: Viewport) => {
      // ÏïΩÍ∞Ñ Îí§Ïóê Ïã§ÌñâÌï¥ÏÑú Î∑∞Í∞Ä ÏôÑÏ†ÑÌûà Îú¨ Îí§ Fit
      setTimeout(() => {
        try {
          // ÌäπÏ†ï Î∑∞Ìè¨Ìä∏Ïóê ÎåÄÌï¥ Fit Ïã§Ìñâ
          void IModelApp.tools.run("View.Fit", vp);
        } catch (e) {
          console.warn("Fit failed:", e);
          // Ïã§Ìå®Ïãú Ï≤´ Î∑∞Ìè¨Ìä∏ ÎåÄÏÉÅÏúºÎ°ú Ìïú Î≤à Îçî ÏãúÎèÑ
          const first = IModelApp.viewManager.getFirstOpenView();
          if (first) void IModelApp.tools.run("View.Fit", first);
        }
      }, 80);
    };
    IModelApp.viewManager.onViewOpen.addListener(onOpen);
    return () => {
      IModelApp.viewManager.onViewOpen.removeListener(onOpen);
    };
  }, [filePath]);
  
  return (
    <>
      {filePath ? (
        // ‚úÖ Í∏∞Ï°¥Ïóê Ïì∞Îçò Viewer JSXÎ•º Í∑∏ÎåÄÎ°ú ÎëêÏÑ∏Ïöî (ÏàòÏ†ï X)
        <Viewer
          rpcInterfaces={viewerRpcs}
          filePath={filePath}
          uiProviders={[
            new ViewerNavigationToolsProvider(),
            new ViewerContentToolsProvider({ vertical: { measureGroup: false } }),
            new ViewerStatusbarItemsProvider(),
            {
              id: "TreeWidgetUIProvider",
              getWidgets: () => [createTreeWidget({
                trees: [
                  {
                    id: ModelsTreeComponent.id,
                    getLabel: () => ModelsTreeComponent.getLabel(),
                    render: (props) => (
                      <ModelsTreeComponent
                        getSchemaContext={(iModel) => iModel.schemaContext}
                        density={props.density}
                        selectionStorage={unifiedSelectionStorage}
                        selectionMode={"extended"}
                        onPerformanceMeasured={props.onPerformanceMeasured}
                        onFeatureUsed={props.onFeatureUsed}
                      />
                    ),
                  },
                  {
                    id: CategoriesTreeComponent.id,
                    getLabel: () => CategoriesTreeComponent.getLabel(),
                    render: (props) => (
                      <CategoriesTreeComponent
                        getSchemaContext={(iModel) => iModel.schemaContext}
                        density={props.density}
                        selectionStorage={unifiedSelectionStorage}
                        onPerformanceMeasured={props.onPerformanceMeasured}
                        onFeatureUsed={props.onFeatureUsed}
                      />
                    ),
                  },
                ],
              })],
            },
            {
              id: "PropertyGridUIProvider",
              getWidgets: () => [createPropertyGrid({
                autoExpandChildCategories: true,
                ancestorsNavigationControls: (props) => (<AncestorsNavigationControls {...props} />),
                contextMenuItems: [(props) => (<CopyPropertyTextContextMenuItem {...props} />)],
                settingsMenuItems: [(props) => (<ShowHideNullValuesSettingsMenuItem {...props} persist={true} />)],
              })],
            },
            new MeasureToolsUiItemsProvider(),
          ]}
          enablePerformanceMonitors={true}
          selectionStorage={unifiedSelectionStorage}
        />
      ) : (
        // ÌååÏùºÏù¥ ÏïÑÏßÅ ÏóÜÏùÑ Îïå Î≥¥Ïó¨Ï§Ñ ÏïàÎÇ¥ (ÏõêÎûò Ïì∞Îçò ÎÇ¥Ïö© Ïú†ÏßÄ/ÏàòÏ†ï)
        <div style={{ padding: 24 }}>
          <h3>Viewer</h3>
          <div>ÌòÑÏû¨ Î°úÎìúÎêú Î™®Îç∏Ïù¥ ÏóÜÏäµÎãàÎã§. ÏÉÅÎã® Î©îÎâ¥Ïùò <b>File ‚Üí Open</b>ÏùÑ ÎàåÎü¨ Ïä§ÎÉÖÏÉ∑ÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.</div>
        </div>
      )}

      {/* ‚úÖ Ïó¨Í∏∞ "return ÌïòÎã®"Ïóê PickDialogÎ•º Ï∂îÍ∞ÄÌï©ÎãàÎã§ */}
      <PickDialog
        open={pickOpen}
        title="Ïä§ÎÉÖÏÉ∑ ÏÑ†ÌÉù"
        items={snapshots}
        render={(s) => (
          <div>
            <div style={{ fontWeight: 700 }}>{s.name}</div>
            <div style={{ fontSize: 12, color: "#888" }}>
              {s.url}{s.siteId ? ` ¬∑ site:${s.siteId}` : ""}
            </div>
          </div>
        )}
        onCancel={() => setPickOpen(false)}
        onPick={async (idx) => {
          const pick = snapshots[idx];
          setPickOpen(false);
          if (!pick) return;

          const local = urlToLocalPath(pick.url);
          if (!local) { alert("Ïä§ÎÉÖÏÉ∑ Ìè¥ÎçîÎ•º Î®ºÏ†Ä ÏÑ§Ï†ïÌïòÏÑ∏Ïöî."); return; }

          setFilePath(local);

          // ‚úÖ ÏµúÍ∑º Ïä§ÎÉÖÏÉ∑ Í∏∞Î°ù (sites.snapshotUrl Í∞±Ïã†)
          try {
            if (siteId) {
              await Api.setSiteLastOpened(siteId, pick.url); // ‚Üê id Ï†ÑÎã¨ Ï†úÍ±∞
            }
            await Api.writeLog?.("open-snapshot", "site", siteId ?? "-", pick.url);
          } catch {}
        }}
      />
    </>
  );
};